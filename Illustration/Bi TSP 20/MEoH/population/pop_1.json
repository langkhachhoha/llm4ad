[
     {
          "algorithm": "{Select the solution with the best objective (smallest cost) in the first space, then perform a segment relocation by moving a segment of nodes to a different position in the tour to create a new neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: x[1][0])\n    \n    # Select the best solution based on the first objective\n    best_solution, _ = sorted_archive[0]\n    \n    # Convert to list for manipulation\n    best_solution = best_solution.tolist()\n    n = len(best_solution)\n    \n    # Select two random indices to form a segment for relocation\n    i, j = np.random.choice(n, 2, replace=False)\n    \n    # Ensure i < j for segment extraction\n    if i > j:\n        i, j = j, i\n    \n    # Extract the segment\n    segment = best_solution[i:j+1]\n    remaining_nodes = best_solution[:i] + best_solution[j+1:]\n    \n    # Create a new position for the segment by selecting a random position in the remaining nodes\n    position = np.random.randint(0, len(remaining_nodes) + 1)\n    \n    # Create the new neighbor solution by inserting the segment\n    new_solution = remaining_nodes[:position] + segment + remaining_nodes[position:]\n    \n    return np.array(new_solution)\n\n",
          "score": [
               -187.25393889289327,
               0.2814743220806122
          ]
     },
     {
          "algorithm": "{Select the solution with the best (minimal) cost in terms of hypervolume, then perform a segment relocation strategy to generate a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: x[1][0])[0]\n\n    # Generate a neighbor solution using segment relocation\n    n = len(best_solution)\n    if n < 4:  # Need at least 4 nodes to perform a meaningful segment relocation\n        return best_solution.copy()\n\n    # Randomly select a segment of the tour to relocate\n    start = np.random.randint(0, n)\n    end = np.random.randint(start + 1, n + 1)  # end is exclusive\n    segment = best_solution[start:end]\n\n    # Remove the segment from the original tour\n    new_solution = np.delete(best_solution, np.s_[start:end], axis=0)\n\n    # Insert the segment at a new position\n    insert_position = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_position, segment)\n\n    return new_solution\n\n",
          "score": [
               -185.44762267328431,
               0.27953439950942993
          ]
     },
     {
          "algorithm": "{The algorithm selects the solution with the best objective score from the archive, identifies nodes with the least contribution to the tour length, and performs a segment relocation to create a new neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: x[1])  # Select the solution with the best (lowest) objectives\n    best_tour = best_solution[0]\n    \n    # Step 2: Identify a segment to relocate\n    N = len(best_tour)\n    segment_start = np.random.randint(0, N)\n    segment_length = np.random.randint(1, N // 2)  # Randomly choose a segment length\n    segment_end = (segment_start + segment_length) % N\n    segment = best_tour[segment_start:segment_end]\n    \n    # Step 3: Remove the segment from the tour\n    new_tour = np.concatenate((best_tour[:segment_start], best_tour[segment_end:]))\n    \n    # Step 4: Select a new position to insert the segment\n    insert_position = np.random.randint(0, len(new_tour) + 1)\n    \n    # Step 5: Insert the segment into the new position\n    neighbor_solution = np.insert(new_tour, insert_position, segment)\n    \n    return neighbor_solution\n\n",
          "score": [
               -242.01204420258526,
               0.3843860626220703
          ]
     },
     {
          "algorithm": "{The algorithm selects the best solution based on the minimum sum of distances from the archive, then performs a segment relocation by moving a segment of the tour to a new position.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    \n    # Step 2: Perform segment relocation\n    n = len(best_solution)\n    if n < 4:\n        return best_solution  # Not enough nodes to perform a meaningful operation\n\n    # Select two random indices for the segment to relocate\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, n)  # Ensure at least two nodes in the segment\n\n    # Extract the segment to be relocated\n    segment = best_solution[start:end]\n    \n    # Remove the segment from the original solution\n    new_tour = np.concatenate((best_solution[:start], best_solution[end:]))\n    \n    # Choose a random position to insert the segment back into the tour\n    insert_position = np.random.randint(0, len(new_tour) + 1)\n    \n    # Create the new neighbor solution by inserting the segment\n    new_tour = np.insert(new_tour, insert_position, segment)\n    \n    return new_tour\n\n",
          "score": [
               -213.40207226574844,
               0.2961995601654053
          ]
     },
     {
          "algorithm": "{Select the solution with the best (lowest) combined distance in both objective spaces and perform a segment relocation to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: (x[1][0] + x[1][1], x[1]))[0]\n    \n    # Step 2: Generate a neighbor solution using segment relocation\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n    \n    # Randomly select two segments from the tour to relocate\n    segment_start = np.random.randint(0, n)\n    segment_end = np.random.randint(segment_start + 1, n + 1)  # Ensure at least one element in the segment\n    \n    # Extract the segment to relocate\n    segment = new_solution[segment_start:segment_end]\n    \n    # Remove the segment from the original solution\n    new_solution = np.delete(new_solution, np.s_[segment_start:segment_end])\n    \n    # Randomly choose a new position to insert the segment\n    new_position = np.random.randint(0, len(new_solution) + 1)\n    \n    # Insert the segment at the new position\n    new_solution = np.insert(new_solution, new_position, segment)\n    \n    return new_solution\n\n",
          "score": [
               -215.57158854549675,
               0.3211843967437744
          ]
     },
     {
          "algorithm": "{Select the solution with the best overall performance in both objectives and apply a segment relocation operator to generate a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    n = len(best_solution)\n    \n    # Perform segment relocation\n    neighbor_solution = best_solution.copy()\n    \n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n)\n    length = np.random.randint(1, n // 2)  # segment length\n    end = (start + length) % n\n    \n    # Extract the segment\n    segment = neighbor_solution[start:end]\n    \n    # Find a position to insert the segment\n    insert_position = np.random.randint(0, n - length)\n    \n    # Create the new neighbor solution\n    if insert_position < start:\n        # Insert before the segment\n        new_solution = np.concatenate((neighbor_solution[:insert_position], segment, neighbor_solution[insert_position:start], neighbor_solution[end:]))\n    else:\n        # Insert after the segment\n        new_solution = np.concatenate((neighbor_solution[:start], neighbor_solution[end:insert_position], segment, neighbor_solution[insert_position:]))\n    \n    return new_solution\n\n",
          "score": [
               -322.77502836800574,
               0.6280213892459869
          ]
     },
     {
          "algorithm": "{Select the solution with the best combined objective values and perform a segment relocation to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]  # Minimize both objectives\n    n = len(best_solution)\n\n    # Select a segment of the tour to relocate\n    start_idx = np.random.randint(0, n)\n    end_idx = np.random.randint(start_idx + 1, n + 1)  # Ensure end_idx is greater than start_idx\n\n    # Extract the segment to relocate\n    segment = best_solution[start_idx:end_idx]\n\n    # Remove the segment from the original solution\n    remaining_nodes = np.concatenate((best_solution[:start_idx], best_solution[end_idx:]))\n\n    # Choose a new position to insert the segment\n    insert_idx = np.random.randint(0, len(remaining_nodes) + 1)\n\n    # Create the new neighbor solution\n    new_solution = np.empty(n, dtype=int)\n    if insert_idx == 0:\n        new_solution[:len(segment)] = segment\n        new_solution[len(segment):] = remaining_nodes\n    elif insert_idx == len(remaining_nodes):\n        new_solution[:len(remaining_nodes)] = remaining_nodes\n        new_solution[len(remaining_nodes):] = segment\n    else:\n        new_solution[:insert_idx] = remaining_nodes[:insert_idx]\n        new_solution[insert_idx:insert_idx + len(segment)] = segment\n        new_solution[insert_idx + len(segment):] = remaining_nodes[insert_idx:]\n\n    return new_solution\n\n",
          "score": [
               -185.4090862295737,
               0.27528834342956543
          ]
     },
     {
          "algorithm": "{Select the solution with the lowest combined objective value from the archive, perform a reinsertion of a segment to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    \n    # Generate a neighbor solution by reinserting a segment\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Choose two random positions to form a segment to be relocated\n    start = np.random.randint(0, n)\n    end = np.random.randint(start + 1, n + 1)\n    \n    # Extract the segment to be relocated\n    segment = new_solution[start:end]\n    \n    # Remove the segment from the original solution\n    new_solution = np.delete(new_solution, np.s_[start:end])\n    \n    # Choose a new position to insert the segment\n    insert_position = np.random.randint(0, len(new_solution) + 1)\n    \n    # Create the new neighbor solution\n    new_solution = np.insert(new_solution, insert_position, segment)\n    \n    return new_solution\n\n",
          "score": [
               -185.9352570972775,
               0.2899821698665619
          ]
     },
     {
          "algorithm": "{Select the best solution based on the minimum distance in both objective spaces and perform a segment relocation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution, _ = min(archive, key=lambda x: (x[1][0], x[1][1]))\n\n    # Step 2: Generate a neighbor solution using segment relocation\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n    \n    # Step 3: Select a random segment to relocate\n    start = np.random.randint(0, n)\n    end = np.random.randint(start + 1, n + 1)  # end is exclusive, so n + 1\n    segment = new_solution[start:end]\n    \n    # Step 4: Remove the segment from the original position\n    new_solution = np.delete(new_solution, np.s_[start:end])\n    \n    # Step 5: Choose a random position to insert the segment\n    insert_position = np.random.randint(0, len(new_solution) + 1)\n    \n    # Step 6: Insert the segment at the new position\n    new_solution = np.insert(new_solution, insert_position, segment)\n    \n    return new_solution\n\n",
          "score": [
               -184.63283766519356,
               0.29001083970069885
          ]
     },
     {
          "algorithm": "{Select a solution from the archive that is closest to the ideal point in the objective space, and perform a segment relocation to generate a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ideal_point = np.min(np.array([obj for _, obj in archive]), axis=0)\n    \n    # Step 2: Find the solution closest to the ideal point\n    closest_solution = min(archive, key=lambda x: np.linalg.norm(np.array(x[1]) - ideal_point))[0]\n    \n    # Step 3: Perform segment relocation on the closest solution\n    n = len(closest_solution)\n    neighbor_solution = closest_solution.copy()\n    \n    # Randomly select a segment of the tour to relocate\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, n // 2)  # Length of the segment to relocate\n    end = (start + length) % n\n    \n    # Extract the segment\n    segment = neighbor_solution[start:end]\n    \n    # Remove the segment from the original solution\n    remaining_nodes = np.setdiff1d(neighbor_solution, segment)\n    \n    # Select a random position to insert the segment\n    insert_position = np.random.randint(0, len(remaining_nodes) + 1)\n    \n    # Create a new neighbor solution by inserting the segment\n    neighbor_solution = np.concatenate((remaining_nodes[:insert_position], segment, remaining_nodes[insert_position:]))\n    \n    return neighbor_solution\n\n",
          "score": [
               -162.41403258266882,
               0.36112961173057556
          ]
     }
]