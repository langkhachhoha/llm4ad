[
     {
          "algorithm": "{Choose the solution with the best trade-off in both objectives and apply a segment relocation strategy.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0]  # Minimizing the sum of objectives\n    best_tour = best_solution.copy()\n    \n    # Step 2: Apply a segment relocation heuristic\n    n = len(best_tour)\n    \n    # Randomly select a segment to relocate\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(1, n // 2)  # Length of the segment to relocate (1 to n//2)\n    \n    segment_end = (segment_start + segment_length) % n\n    segment = best_tour[segment_start:segment_end]\n    \n    # Remove the segment from the tour\n    remaining_tour = np.concatenate((best_tour[:segment_start], best_tour[segment_end:]))\n    \n    # Insert the segment back into the tour at a new position\n    insert_position = np.random.randint(0, len(remaining_tour) + 1)\n    new_tour = np.insert(remaining_tour, insert_position, segment)\n    \n    return new_tour\n\n",
          "score": [
               -277.16016416614025,
               0.3989095091819763
          ]
     },
     {
          "algorithm": "{Select the solution from the archive that has the lowest combined cost in both objective spaces, and then apply a segment relocation strategy to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda s: s[1][0] + s[1][1])[0]\n    \n    # Convert to list for manipulation\n    selected_solution = selected_solution.tolist()\n    n = len(selected_solution)\n    \n    # Implementing a segment relocation strategy\n    # Randomly choose a segment of the tour to relocate\n    start = np.random.randint(0, n)\n    end = np.random.randint(start + 1, n + 1)  # end is exclusive\n    \n    # Segment to relocate\n    segment = selected_solution[start:end]\n    \n    # Remove the segment from the current position\n    new_solution = selected_solution[:start] + selected_solution[end:]\n    \n    # Choose a new position to insert the segment\n    insert_position = np.random.randint(0, len(new_solution) + 1)\n    \n    # Create the new neighbor solution\n    new_solution = new_solution[:insert_position] + segment + new_solution[insert_position:]\n    \n    return np.array(new_solution)\n\n",
          "score": [
               -217.04713601851455,
               0.2766856849193573
          ]
     },
     {
          "algorithm": "{Select the solution with the best objective (minimum cost in both objectives) from the archive, and apply a segment relocation strategy to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution, _ = min(archive, key=lambda x: (x[1][0], x[1][1]))\n\n    # Step 2: Generate a neighbor solution using segment relocation\n    n = len(best_solution)\n    neighbor_solution = best_solution.copy()\n\n    # Randomly choose two segments to relocate\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(1, n // 2)  # Ensure the segment length is reasonable\n    segment_end = (segment_start + segment_length) % n\n    \n    # Extract the segment to relocate\n    segment = neighbor_solution[segment_start:segment_end]\n\n    # Remove the segment from the original position\n    remaining_nodes = np.concatenate((neighbor_solution[:segment_start], neighbor_solution[segment_end:]))\n    \n    # Choose a new position to insert the segment\n    insert_position = np.random.randint(0, len(remaining_nodes) + 1)\n    \n    # Create the new neighbor solution\n    neighbor_solution = np.insert(remaining_nodes, insert_position, segment)\n    \n    return neighbor_solution\n\n",
          "score": [
               -259.28473320718695,
               0.37558674812316895
          ]
     },
     {
          "algorithm": "{Select the solution from the archive with the best performance in both objectives and apply a segment relocation strategy.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]  # Choose solution with best objectives\n    best_tour = best_solution.copy()\n    \n    # Step 2: Apply a segment relocation strategy\n    n = len(best_tour)\n    if n < 4:  # Not enough nodes to perform a meaningful operation\n        return best_tour\n    \n    # Step 3: Select two segments to relocate\n    segment_start = np.random.randint(0, n - 2)  # Randomly choose a start for the first segment\n    segment_end = np.random.randint(segment_start + 1, n)  # Ensure the end is after start\n    segment = best_tour[segment_start:segment_end]  # Extract the segment\n    \n    # Step 4: Remove the segment from the tour\n    new_tour = np.delete(best_tour, np.s_[segment_start:segment_end], axis=0)\n    \n    # Step 5: Insert the segment at a new position\n    insert_position = np.random.randint(0, len(new_tour) + 1)  # Choose a new position to insert segment\n    new_tour = np.insert(new_tour, insert_position, segment)  # Insert segment\n\n    return new_tour\n\n",
          "score": [
               -188.98227689621962,
               0.2985736131668091
          ]
     },
     {
          "algorithm": "{Select the solution with the best trade-off in objectives (least cost) and perform a segment relocation to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: x[1][0])[0]  # Minimize first objective\n    n = len(best_solution)\n    \n    # Step 2: Choose two random indices to define a segment\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i  # Ensure i < j\n\n    # Step 3: Extract the segment and the remaining nodes\n    segment = best_solution[i:j + 1]\n    remaining_nodes = np.concatenate((best_solution[:i], best_solution[j + 1:]))\n    \n    # Step 4: Relocate the segment to a new position in the remaining nodes\n    # Select a new position to insert the segment\n    insert_position = np.random.randint(0, len(remaining_nodes) + 1)\n    \n    # Step 5: Create the new neighbor solution\n    new_solution = np.concatenate((remaining_nodes[:insert_position], segment, remaining_nodes[insert_position:]))\n    \n    return new_solution\n\n",
          "score": [
               -184.11582697713345,
               0.28468263149261475
          ]
     },
     {
          "algorithm": "{Identify a solution with the best compromise between both objectives, then perform a segment relocation to generate a neighbor.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    best_solution, _ = archive_sorted[0]  # Select the first (best) solution\n    \n    # Perform a segment relocation to create a neighbor solution\n    n = len(best_solution)\n    if n < 4:  # Need at least 4 nodes to perform a segment relocation\n        return best_solution\n    \n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n-2)\n    end = np.random.randint(start + 2, n)  # Ensure at least one node is between start and end\n    \n    # Extract the segment to relocate\n    segment = best_solution[start:end]\n    \n    # Create a new tour by removing the segment from the original tour\n    new_tour = np.concatenate((best_solution[:start], best_solution[end:]))\n    \n    # Randomly select a position to insert the segment\n    insert_position = np.random.randint(0, len(new_tour) + 1)\n    \n    # Insert the segment into the new tour\n    new_tour = np.insert(new_tour, insert_position, segment)\n    \n    return new_tour\n\n",
          "score": [
               -184.62983820750992,
               0.29651209712028503
          ]
     },
     {
          "algorithm": "{Select a solution from the archive with the best combined distance in both objective spaces, then apply a reinsertion strategy to enhance the local search.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    \n    # Step 2: Create a neighbor solution using a reinsertion strategy\n    n = len(best_solution)\n    neighbor_solution = best_solution.copy()\n\n    # Step 3: Choose two random indices to perform reinsertion\n    i, j = np.random.choice(n, 2, replace=False)\n    \n    # Step 4: Remove the node at index i and insert it after index j\n    node_to_reinsert = neighbor_solution[i]\n    neighbor_solution = np.delete(neighbor_solution, i)\n    \n    # Ensure j is adjusted if i was before j\n    if i < j:\n        j -= 1\n        \n    neighbor_solution = np.insert(neighbor_solution, j, node_to_reinsert)\n    \n    return neighbor_solution\n\n",
          "score": [
               -205.7027311001587,
               0.3011893630027771
          ]
     },
     {
          "algorithm": "{Select the solution with the best combined objective values from the archive, then perform a segment relocation by moving a segment of nodes to a new position in the tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]  # Selecting based on the first objective, then second\n    \n    # Step 2: Create a neighbor solution by relocating a segment\n    n = len(best_solution)\n    if n < 4:  # Not enough nodes to perform the operation\n        return best_solution\n    \n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n-2)  # Avoiding last node\n    end = np.random.randint(start + 1, n-1)  # Ensure end is after start and not the last node\n    \n    # Extract the segment\n    segment = best_solution[start:end + 1]\n    \n    # Remove the segment from the original solution\n    new_solution = np.delete(best_solution, np.s_[start:end + 1])\n    \n    # Find a random insertion point\n    insert_position = np.random.randint(0, len(new_solution) + 1)\n\n    # Create the new neighbor solution by inserting the segment\n    neighbor_solution = np.insert(new_solution, insert_position, segment)\n    \n    return neighbor_solution\n\n",
          "score": [
               -182.810283643837,
               0.29493722319602966
          ]
     },
     {
          "algorithm": "{The algorithm selects the solution with the best overall performance based on objectives and applies a segment relocation strategy to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: x[1])  # minimize based on tuple (negative_hypervolume, time_to_finish)\n    best_tour = best_solution[0].copy()\n    \n    # Apply segment relocation\n    n = len(best_tour)\n    if n < 4:  # Need at least four nodes to relocate a segment\n        return best_tour\n    \n    # Select two random indices to define the segment to relocate\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i  # Ensure i < j\n    \n    # Extract the segment to relocate\n    segment = best_tour[i:j+1]\n    \n    # Remove the segment from the tour\n    new_tour = np.concatenate((best_tour[:i], best_tour[j+1:]))\n    \n    # Choose a new position to insert the segment\n    insert_position = np.random.randint(0, len(new_tour) + 1)\n    \n    # Create the new neighbor solution\n    neighbor_solution = np.insert(new_tour, insert_position, segment)\n    \n    return neighbor_solution\n\n",
          "score": [
               -183.99766824179983,
               0.2956540286540985
          ]
     },
     {
          "algorithm": "{Select the solution with the best combined objective score (lowest cost in both spaces) and apply a segment relocation strategy to generate a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    \n    # Choose a random segment to relocate\n    n = len(best_solution)\n    segment_length = np.random.randint(2, n // 2)  # Length of segment to relocate\n    start_index = np.random.randint(0, n - segment_length + 1)  # Start index of segment\n    segment = best_solution[start_index:start_index + segment_length]\n    \n    # Remove segment from its original position\n    new_solution = np.delete(best_solution, np.s_[start_index:start_index + segment_length])\n    \n    # Choose a new position to insert the segment\n    insert_index = np.random.randint(0, len(new_solution) + 1)\n    \n    # Create the new neighbor solution by inserting the segment\n    neighbor_solution = np.insert(new_solution, insert_index, segment)\n    \n    return neighbor_solution\n\n",
          "score": [
               -182.09062878505136,
               0.2956802248954773
          ]
     }
]