[
     {
          "algorithm": "{The algorithm selects the solution with the best combined objective values from the archive, identifies a segment of the tour to relocate, and reinserts it into a new position within the tour to generate a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: x[1])  # Minimize both objectives\n    current_tour = best_solution[0]\n\n    # Step 2: Choose two random indices to form a segment to relocate\n    length = len(current_tour)\n    start_index = np.random.randint(0, length)\n    segment_length = np.random.randint(1, length // 2)  # Ensure the segment is not too large\n    end_index = (start_index + segment_length) % length\n\n    # Step 3: Extract the segment\n    if start_index < end_index:\n        segment = current_tour[start_index:end_index]\n    else:\n        segment = np.concatenate((current_tour[start_index:], current_tour[:end_index]))\n\n    # Step 4: Remove the segment from the current tour\n    new_tour = np.delete(current_tour, np.s_[start_index:end_index], axis=0)\n\n    # Step 5: Choose a new insertion point for the segment\n    insert_index = np.random.randint(0, len(new_tour) + 1)\n\n    # Step 6: Create the new neighbor solution by inserting the segment\n    neighbor_solution = np.insert(new_tour, insert_index, segment)\n\n    return neighbor_solution\n\n",
          "score": [
               -339.30145199050605,
               0.6893910467624664
          ]
     },
     {
          "algorithm": "{Select the solution with the best trade-off based on hypervolume and apply a segment relocation strategy to generate a new neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    \n    n = len(best_solution)\n    # Select a segment of the tour to relocate\n    start_index = np.random.randint(0, n)\n    segment_length = np.random.randint(1, n // 2)  # Ensure segment is not too large\n    end_index = (start_index + segment_length) % n\n    \n    # Extract segment\n    if start_index < end_index:\n        segment = best_solution[start_index:end_index]\n    else:\n        segment = np.concatenate((best_solution[start_index:], best_solution[:end_index]))\n    \n    # Remove the segment from the solution\n    remaining_nodes = np.delete(best_solution, np.s_[start_index:end_index])\n    \n    # Select a position to reinsert the segment\n    insert_position = np.random.randint(0, len(remaining_nodes) + 1)\n    \n    # Create the new neighbor solution\n    new_solution = np.concatenate((remaining_nodes[:insert_position], segment, remaining_nodes[insert_position:]))\n    \n    return new_solution\n\n",
          "score": [
               -327.2044814767568,
               0.6826744079589844
          ]
     },
     {
          "algorithm": "{The new algorithm selects a solution from the archive with the best trade-off between the two objectives and applies a segment relocation strategy, where a non-adjacent segment of the tour is relocated to a different position in the tour to explore new neighborhoods effectively.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    ideal_point = np.array([0.0, 0.0])  # Assuming lower values are better\n    \n    # Step 2: Select the solution with the best trade-off (closest to ideal point)\n    best_solution = None\n    best_distance = float('inf')\n    \n    for solution, objectives in archive:\n        distance = np.linalg.norm(np.array(objectives) - ideal_point)\n        if distance < best_distance:\n            best_distance = distance\n            best_solution = solution\n    \n    # Step 3: Apply a segment relocation strategy\n    n = len(best_solution)\n    neighbor_solution = best_solution.copy()\n    \n    # Randomly select two non-adjacent segments to relocate\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(1, n // 2)  # Ensure the segment is not too large\n    segment_end = (segment_start + segment_length) % n\n    \n    if segment_end < segment_start:\n        segment = neighbor_solution[segment_start:].tolist() + neighbor_solution[:segment_end].tolist()\n    else:\n        segment = neighbor_solution[segment_start:segment_end].tolist()\n    \n    remaining_nodes = np.concatenate((neighbor_solution[:segment_start], neighbor_solution[segment_end:]))\n    \n    # Choose a random position to relocate the segment\n    insert_position = np.random.randint(0, len(remaining_nodes) + 1)\n    \n    # Create the new neighbor solution\n    neighbor_solution = np.concatenate((remaining_nodes[:insert_position], segment, remaining_nodes[insert_position:]))\n    \n    return neighbor_solution\n\n",
          "score": [
               -245.35169326716056,
               2.1916893124580383
          ]
     },
     {
          "algorithm": "{The new algorithm selects a solution from the archive that has the best trade-off between the two objectives, then applies a two-segment swap strategy, where two non-overlapping segments of the tour are exchanged to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))  # Minimize the sum of both objectives\n    current_tour = best_solution[0]\n\n    n = len(current_tour)\n    neighbor_solution = current_tour.copy()\n\n    # Choose two non-overlapping segments to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i  # Ensure i < j\n\n    # Define the first segment\n    segment1 = neighbor_solution[i:j+1]\n\n    # Choose a second segment that does not overlap with the first\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k  # Ensure k < l\n    # Ensure the segments are non-overlapping\n    while (i <= l and j >= k) or (k <= j and l >= i):\n        k, l = np.random.choice(n, 2, replace=False)\n        if k > l:\n            k, l = l, k\n\n    # Define the second segment\n    segment2 = neighbor_solution[k:l+1]\n\n    # Remove both segments from the current tour\n    remaining_nodes = np.concatenate((neighbor_solution[:i], neighbor_solution[j+1:k], neighbor_solution[l+1:]))\n\n    # Insert the segments back into the remaining nodes at new positions\n    insert_pos1 = np.random.randint(0, len(remaining_nodes) + 1)\n    neighbor_solution = np.concatenate((remaining_nodes[:insert_pos1], segment1, remaining_nodes[insert_pos1:]))\n    \n    insert_pos2 = np.random.randint(0, len(neighbor_solution) + 1)\n    neighbor_solution = np.concatenate((neighbor_solution[:insert_pos2], segment2, neighbor_solution[insert_pos2:]))\n\n    return neighbor_solution\n\n",
          "score": [
               -233.5122511418213,
               2.025418072938919
          ]
     },
     {
          "algorithm": "{The new algorithm selects a solution from the archive that is closest to the Pareto front and applies a reverse segment strategy, where a contiguous segment of the tour is reversed to explore new neighborhoods while preserving the overall structure of the tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]  # Minimize the sum of both objectives\n    \n    # Step 2: Apply a reverse segment strategy\n    n = len(best_solution)\n    neighbor_solution = best_solution.copy()\n    \n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n)\n    end = np.random.randint(0, n)\n    if start > end:\n        start, end = end, start  # Ensure start < end\n\n    # Reverse the selected segment\n    segment_to_reverse = neighbor_solution[start:end + 1]\n    neighbor_solution[start:end + 1] = segment_to_reverse[::-1]\n\n    return neighbor_solution\n\n",
          "score": [
               -220.79347385881402,
               0.2874695658683777
          ]
     },
     {
          "algorithm": "{The new algorithm selects a solution from the archive that has the highest potential for improvement by applying a \"shift and reverse\" strategy, where a segment of the tour is shifted to a new position and the order of the nodes in that segment is reversed to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    \n    n = len(best_solution)\n    \n    # Randomly select a segment to reverse and shift\n    start_index = np.random.randint(0, n)\n    segment_length = np.random.randint(1, n // 2)  # Segment length between 1 and n//2\n    end_index = (start_index + segment_length) % n  # Wrap around for circular tour\n    \n    # Extract the segment\n    if start_index < end_index:\n        segment = best_solution[start_index:end_index][::-1]  # Reverse the segment\n        remaining_nodes = np.concatenate((best_solution[:start_index], best_solution[end_index:]))\n    else:\n        segment = best_solution[start_index:][::-1].tolist() + best_solution[:end_index][::-1].tolist()  # Reverse the segment\n        remaining_nodes = best_solution[end_index:start_index]\n    \n    # Choose a new position to insert the reversed segment\n    insert_position = np.random.randint(0, len(remaining_nodes) + 1)\n    \n    # Create the new neighbor solution\n    new_solution = np.concatenate((remaining_nodes[:insert_position], segment, remaining_nodes[insert_position:]))\n    \n    return new_solution\n\n",
          "score": [
               -219.06588285216492,
               0.25773507356643677
          ]
     },
     {
          "algorithm": "{The new algorithm selects a solution from the archive that has the best balance between objectives, then applies a segment relocation strategy where a contiguous segment of nodes is relocated to a different position in the tour to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    \n    n = len(best_solution)\n    \n    # Randomly select a segment of the tour to relocate\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(1, n - segment_start + 1)\n    segment_end = segment_start + segment_length\n    \n    # Extract the segment to relocate\n    segment = best_solution[segment_start:segment_end]\n    \n    # Remove the segment from the original solution\n    remaining_nodes = np.concatenate((best_solution[:segment_start], best_solution[segment_end:]))\n    \n    # Choose a new position to insert the segment\n    insert_position = np.random.randint(0, len(remaining_nodes) + 1)\n    \n    # Create the new neighbor solution by inserting the segment at the new position\n    new_solution = np.concatenate((remaining_nodes[:insert_position], segment, remaining_nodes[insert_position:]))\n    \n    return new_solution\n\n",
          "score": [
               -216.8716261009938,
               0.2843509912490845
          ]
     },
     {
          "algorithm": "{The new algorithm selects a solution from the archive that has the maximum distance reduction potential for an edge in the tour by applying a segment relocation strategy, which removes a contiguous segment of the tour and reinserts it at a different position to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    \n    n = len(best_solution)\n    \n    # Randomly select a segment to remove\n    start_index = np.random.randint(0, n)\n    segment_length = np.random.randint(1, n // 2)  # Segment length between 1 and n//2\n    end_index = (start_index + segment_length) % n  # Wrap around for circular tour\n    \n    # Extract the segment\n    if start_index < end_index:\n        segment = best_solution[start_index:end_index]\n        remaining_nodes = np.concatenate((best_solution[:start_index], best_solution[end_index:]))\n    else:\n        segment = np.concatenate((best_solution[start_index:], best_solution[:end_index]))\n        remaining_nodes = best_solution[end_index:start_index]\n    \n    # Choose a new position to insert the segment\n    insert_position = np.random.randint(0, len(remaining_nodes) + 1)\n    \n    # Create the new neighbor solution\n    new_solution = np.concatenate((remaining_nodes[:insert_position], segment, remaining_nodes[insert_position:]))\n    \n    return new_solution\n\n",
          "score": [
               -216.5015876287568,
               0.2715598940849304
          ]
     },
     {
          "algorithm": "{The algorithm selects the solution from the archive that is closest to the ideal point in the objective space, then applies a local transformation based on a segment relocation strategy to generate a promising neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    ideal_point = np.array([0, 0])  # Assuming minimization of both objectives\n    \n    # Select the solution that is closest to the ideal point\n    closest_solution = None\n    closest_distance = float('inf')\n\n    for solution, (cost1, cost2) in archive:\n        distance = np.linalg.norm(np.array([cost1, cost2]) - ideal_point)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_solution = solution\n\n    # Generate a neighbor solution using segment relocation\n    n = len(closest_solution)\n    neighbor_solution = closest_solution.copy()\n    \n    # Choose two random indices to relocate the segment\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i  # Ensure i < j\n    \n    # Relocate the segment from i to j\n    segment = neighbor_solution[i:j+1]\n    remaining_nodes = np.concatenate((neighbor_solution[:i], neighbor_solution[j+1:]))\n    \n    # Insert the segment back into a new position in the remaining nodes\n    insert_position = np.random.randint(0, len(remaining_nodes) + 1)\n    neighbor_solution = np.concatenate((remaining_nodes[:insert_position], segment, remaining_nodes[insert_position:]))\n    \n    return neighbor_solution\n\n",
          "score": [
               -216.17408630572572,
               0.5358310043811798
          ]
     },
     {
          "algorithm": "{The new algorithm selects a solution from the archive that has the best diversity in objectives, then applies a segment reversal strategy where a contiguous segment of the tour is reversed to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: (x[1][0]**2 + x[1][1]**2))  # Minimize the squared objectives for diversity\n    current_tour = best_solution[0]\n    \n    n = len(current_tour)\n    \n    # Randomly select a segment of the tour to reverse\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n    \n    # Extract the segment to reverse\n    segment = current_tour[start:end+1]\n    \n    # Reverse the segment\n    segment_reversed = segment[::-1]\n    \n    # Create the new neighbor solution by combining the remaining nodes and the reversed segment\n    new_solution = np.concatenate((current_tour[:start], segment_reversed, current_tour[end+1:]))\n    \n    return new_solution\n\n",
          "score": [
               -215.4111888014286,
               0.41636621952056885
          ]
     }
]