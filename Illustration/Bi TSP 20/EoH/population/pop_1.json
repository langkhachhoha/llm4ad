[
     {
          "algorithm": "{The algorithm selects the solution with the best combined objective values from the archive, identifies a segment of the tour to relocate, and reinserts it into a new position within the tour to generate a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: x[1])  # Minimize both objectives\n    current_tour = best_solution[0]\n\n    # Step 2: Choose two random indices to form a segment to relocate\n    length = len(current_tour)\n    start_index = np.random.randint(0, length)\n    segment_length = np.random.randint(1, length // 2)  # Ensure the segment is not too large\n    end_index = (start_index + segment_length) % length\n\n    # Step 3: Extract the segment\n    if start_index < end_index:\n        segment = current_tour[start_index:end_index]\n    else:\n        segment = np.concatenate((current_tour[start_index:], current_tour[:end_index]))\n\n    # Step 4: Remove the segment from the current tour\n    new_tour = np.delete(current_tour, np.s_[start_index:end_index], axis=0)\n\n    # Step 5: Choose a new insertion point for the segment\n    insert_index = np.random.randint(0, len(new_tour) + 1)\n\n    # Step 6: Create the new neighbor solution by inserting the segment\n    neighbor_solution = np.insert(new_tour, insert_index, segment)\n\n    return neighbor_solution\n\n",
          "score": [
               -339.30145199050605,
               0.6893910467624664
          ]
     },
     {
          "algorithm": "{The algorithm selects the solution from the archive that is closest to the ideal point in the objective space, then applies a local transformation based on a segment relocation strategy to generate a promising neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    ideal_point = np.array([0, 0])  # Assuming minimization of both objectives\n    \n    # Select the solution that is closest to the ideal point\n    closest_solution = None\n    closest_distance = float('inf')\n\n    for solution, (cost1, cost2) in archive:\n        distance = np.linalg.norm(np.array([cost1, cost2]) - ideal_point)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_solution = solution\n\n    # Generate a neighbor solution using segment relocation\n    n = len(closest_solution)\n    neighbor_solution = closest_solution.copy()\n    \n    # Choose two random indices to relocate the segment\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i  # Ensure i < j\n    \n    # Relocate the segment from i to j\n    segment = neighbor_solution[i:j+1]\n    remaining_nodes = np.concatenate((neighbor_solution[:i], neighbor_solution[j+1:]))\n    \n    # Insert the segment back into a new position in the remaining nodes\n    insert_position = np.random.randint(0, len(remaining_nodes) + 1)\n    neighbor_solution = np.concatenate((remaining_nodes[:insert_position], segment, remaining_nodes[insert_position:]))\n    \n    return neighbor_solution\n\n",
          "score": [
               -216.17408630572572,
               0.5358310043811798
          ]
     },
     {
          "algorithm": "{The algorithm identifies a promising solution from the archive based on its proximity to the ideal point in the objective space, then applies a segment relocation strategy that moves a contiguous segment of nodes to a new position in the tour to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ideal_point = (0, 0)  # Assuming we want to minimize both objectives\n    selected_solution = min(archive, key=lambda x: np.linalg.norm(np.array(x[1]) - np.array(ideal_point)))[0]\n    \n    # Step 2: Convert selected_solution to a list for easier manipulation\n    tour = selected_solution.tolist()\n    n = len(tour)\n    \n    # Step 3: Choose two random indices to define the segment to relocate\n    start = np.random.randint(0, n)\n    end = np.random.randint(start + 1, n + 1)  # end is exclusive\n    segment = tour[start:end]\n\n    # Step 4: Remove the segment from the original tour\n    remaining_tour = tour[:start] + tour[end:]\n\n    # Step 5: Insert the segment at a new position in the remaining tour\n    insert_position = np.random.randint(0, len(remaining_tour) + 1)  # +1 to allow insertion at the end\n    new_tour = remaining_tour[:insert_position] + segment + remaining_tour[insert_position:]\n\n    # Step 6: Convert back to a numpy array and return\n    return np.array(new_tour)\n\n",
          "score": [
               -214.2891430720001,
               0.5102773904800415
          ]
     },
     {
          "algorithm": "{The algorithm selects the solution from the archive with the lowest combined distance in both objective spaces and applies a segment relocation strategy, where a segment of the tour is moved to a new position to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    \n    # Step 2: Generate a neighbor solution using segment relocation\n    n = len(best_solution)\n    \n    # Choose two random indices to define a segment\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    \n    if i > j:\n        i, j = j, i  # Ensure i < j\n\n    # Extract the segment and the remaining nodes\n    segment = best_solution[i:j+1]\n    remaining = np.concatenate((best_solution[:i], best_solution[j+1:]))\n    \n    # Randomly choose a new position to insert the segment\n    new_position = np.random.randint(0, len(remaining) + 1)\n    \n    # Create the new neighbor solution\n    new_solution = np.concatenate((remaining[:new_position], segment, remaining[new_position:]))\n    \n    return new_solution\n\n",
          "score": [
               -213.3795563902026,
               0.29018324613571167
          ]
     },
     {
          "algorithm": "{The algorithm selects the solution with the closest objective values to the ideal point in the archive, then applies a reinsertion strategy where a segment of the tour is removed and reinserted at a different position to create a promising neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ideal_point = np.array([0.0, 0.0])  # Assuming lower values are better\n    \n    # Step 2: Select the solution with the closest objectives to the ideal point\n    best_solution = None\n    best_distance = float('inf')\n    \n    for solution, objectives in archive:\n        distance = np.linalg.norm(np.array(objectives) - ideal_point)\n        if distance < best_distance:\n            best_distance = distance\n            best_solution = solution\n    \n    # Step 3: Apply a reinsertion strategy\n    n = len(best_solution)\n    neighbor_solution = best_solution.copy()\n    \n    # Randomly choose a segment to remove and find a position to reinsert\n    start = np.random.randint(0, n)\n    end = np.random.randint(start + 1, n + 1)\n    \n    segment = neighbor_solution[start:end]\n    remaining_nodes = np.concatenate((neighbor_solution[:start], neighbor_solution[end:]))\n    \n    # Choose a random position to reinsert the segment\n    insert_position = np.random.randint(0, len(remaining_nodes) + 1)\n    \n    # Create the new neighbor solution\n    neighbor_solution = np.concatenate((remaining_nodes[:insert_position], segment, remaining_nodes[insert_position:]))\n    \n    return neighbor_solution\n\n",
          "score": [
               -213.15478925416025,
               0.4788981080055237
          ]
     },
     {
          "algorithm": "{The algorithm selects the best solution from the archive based on the minimum total distance in both objective spaces, then applies a segment relocation strategy to create a neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: x[1][0])[0]\n\n    # Apply a segment relocation strategy\n    n = len(best_solution)\n    neighbor_solution = best_solution.copy()\n    \n    # Randomly select a segment to relocate\n    start = np.random.randint(1, n - 1)  # Avoid the first and last node\n    end = np.random.randint(start + 1, n)  # Ensure end is after start\n\n    # Extract the segment to relocate\n    segment = neighbor_solution[start:end].copy()\n    remaining_nodes = np.delete(neighbor_solution, np.arange(start, end))\n\n    # Find a promising position to insert the segment\n    insert_position = np.random.randint(1, len(remaining_nodes) + 1)\n    \n    # Create the new neighbor solution\n    neighbor_solution = np.concatenate((remaining_nodes[:insert_position], segment, remaining_nodes[insert_position:]))\n\n    return neighbor_solution\n\n",
          "score": [
               -187.95147085981995,
               0.276950478553772
          ]
     },
     {
          "algorithm": "{The algorithm selects the solution from the archive with the best combined objective value and generates a neighbor solution by performing a segment relocation, where a contiguous subsequence of the tour is moved to a new position in the tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    \n    # Generate a neighbor solution using segment relocation\n    n = len(best_solution)\n    \n    # Randomly choose a segment length and position\n    segment_length = np.random.randint(2, n // 2)  # Ensuring the segment is not too small or too large\n    start_index = np.random.randint(0, n - segment_length)\n    \n    # Extract the segment to be relocated\n    segment = best_solution[start_index:start_index + segment_length]\n    \n    # Remove the segment from the original solution\n    new_solution = np.delete(best_solution, np.s_[start_index:start_index + segment_length])\n    \n    # Randomly choose a new position to insert the segment\n    insert_index = np.random.randint(0, len(new_solution) + 1)\n    \n    # Insert the segment into the new position\n    new_solution = np.insert(new_solution, insert_index, segment)\n    \n    return new_solution\n\n",
          "score": [
               -185.30036253047126,
               0.28508490324020386
          ]
     },
     {
          "algorithm": "{The algorithm selects the solution with the best overall performance in the archive based on the hypervolume indicator, then applies a segment relocation strategy by moving a contiguous segment of the tour to a new position, aiming to explore promising regions of the solution space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: x[1][0])[0]\n    \n    # Step 2: Perform segment relocation\n    n = len(best_solution)\n    \n    # Randomly choose a segment to relocate\n    start = np.random.randint(0, n)\n    end = np.random.randint(start + 1, n + 1)  # end is exclusive, hence +1\n    \n    segment = best_solution[start:end]\n    remaining = np.concatenate((best_solution[:start], best_solution[end:]))\n    \n    # Choose a random insertion point\n    insertion_point = np.random.randint(0, len(remaining) + 1)\n    \n    # Create the new neighbor by inserting the segment at the new position\n    neighbor_solution = np.concatenate((remaining[:insertion_point], segment, remaining[insertion_point:]))\n    \n    return neighbor_solution\n\n",
          "score": [
               -182.00452956387358,
               0.2680653929710388
          ]
     },
     {
          "algorithm": "{The algorithm identifies the solution with the lowest total distance in both objective spaces, then applies a reinsertion strategy to generate a neighbor solution by moving a randomly selected node to a new position in the tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    \n    # Create a copy of the best solution to generate a neighbor\n    neighbor = best_solution.copy()\n    \n    # Choose two random indices to perform the reinsertion\n    n = len(neighbor)\n    idx_to_move = np.random.randint(1, n-1)  # avoid the first and last node\n    node_to_move = neighbor[idx_to_move]\n    \n    # Remove the node from its current position\n    neighbor = np.delete(neighbor, idx_to_move)\n    \n    # Choose a new position to reinsert the node\n    new_position = np.random.randint(1, n-1)  # avoid the first and last node again\n    neighbor = np.insert(neighbor, new_position, node_to_move)\n    \n    return neighbor\n\n",
          "score": [
               -177.64412242063685,
               0.29570916295051575
          ]
     },
     {
          "algorithm": "{Select the solution with the best overall performance in the archive and apply a segment relocation strategy to generate a new neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (negative_hypervolume, time_to_finish).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0]\n    \n    # Step 2: Perform a segment relocation\n    n = len(best_solution)\n    start = np.random.randint(0, n)\n    end = np.random.randint(0, n)\n    \n    if start > end:\n        start, end = end, start\n    \n    # Step 3: Extract the segment\n    segment = best_solution[start:end + 1]\n    \n    # Step 4: Remove the segment from the original solution\n    remaining_nodes = np.setdiff1d(best_solution, segment)\n    \n    # Step 5: Select a random position to reinsert the segment\n    insert_position = np.random.randint(0, len(remaining_nodes) + 1)\n    \n    # Step 6: Create the new neighbor solution\n    new_solution = np.concatenate((remaining_nodes[:insert_position], segment, remaining_nodes[insert_position:]))\n    \n    return new_solution\n\n",
          "score": [
               -167.31361323573896,
               0.3375173509120941
          ]
     }
]